<!DOCTYPE HTML>
<html lang="en-US">
<head>
    <meta charset="UTF-8">
    <title>Solar system</title>
    <link rel="stylesheet" href="css/normalize.css">
    <style>
        body { margin: 0; background-color: #000; color: #fff;}
    </style>
</head>
<body>
<canvas id="Js_canvas">Sorry!你的浏览器落伍了！</canvas>
<script src="js/Kanvas.js"></script>
<script>
(function(){
    var K3D = Kanvas._3D;
    var width = window.innerWidth;
    var height = window.innerHeight - 5;
    var canvas = Kanvas.getCanvas("#Js_canvas", {width: width, height: height});
    var ctx = canvas.getContext("2d");

    K3D.setVanishPoint(width / 2, height / 2);
    K3D.setRotateAngle({
        rotateXAngle: Math.PI / 6
    });

    var Planet = Class.extend({
        init: function(obj){
            this.coordinate = obj.coordinate;
            this.radius = obj.radius;
            this.color = obj.color;
        },
        draw: function(){
            var cartesianCenter = K3D.spherical(this.coordinate.a, this.coordinate.b, this.coordinate.r),
                x0 = cartesianCenter.x,
                y0 = cartesianCenter.y,
                z0 = cartesianCenter.z,
                center = K3D.projection(x0, y0, z0),
                rr = this.radius * this.radius,
                factY,
                z;
            ctx.beginPath();
            ctx.strokeStyle = this.color;
            for (var i = -this.radius + x0; i <= this.radius + x0; i += 1) {
                factY = Math.sqrt(rr - (i - x0) * (i - x0));
                for (var j = -factY + y0; j <= factY + y0; j += 1) {
                    z = Math.sqrt(rr - (i - x0) * (i - x0) - (j - y0) * (j - y0));
                    surface0 = K3D.projection(i, j, z + z0);
                    surface1 = K3D.projection(i, j, -z + z0);
                    ctx.moveTo(center.x, center.y);
                    ctx.lineTo(surface0.x, surface0.y);
                    ctx.moveTo(center.x, center.y);
                    ctx.lineTo(surface1.x, surface1.y);

                }
            }
            ctx.stroke();
            ctx.closePath();
        },
        draw1: function(){
            var cartesianCenter = K3D.spherical(this.coordinate.a, this.coordinate.b, this.coordinate.r),
                x0 = cartesianCenter.x,
                y0 = cartesianCenter.y,
                z0 = cartesianCenter.z,
                rr = this.radius * this.radius,
                x, y, z, t, co0, co, zz,
                max;
            z = - this.radius;
            ctx.strokeStyle = this.color;
            ctx.beginPath();
            while(z < this.radius) {
                zz = z * z;
                x = - Math.sqrt(rr - zz);
                y = 0;
                t = 1;
                co0 = K3D.projection(x, y, z);
                ctx.moveTo(co0.x, co0.y);
                console.time(1);
                while(true) {
                    y = Math.sqrt(rr - x * x - zz) * t;
                    if(isNaN(y)){
                        if (t === 1) {
                            t = -t;
                            x = Math.sqrt(rr - zz);
                            continue;
                        }
                        else break;
                    }
                    co = K3D.projection(x, y, z);
                    ctx.lineTo(co.x, co.y);
                    x += 2 * t;
                }
                ctx.lineTo(co0.x, co0.y);
                z = z + 10;
            }
            console.timeEnd(1);
            ctx.stroke();
            ctx.closePath();
        }
    });

    function drawEllipse(x, y, a, b) {
        var k = .5522848,
            ox = a * k, // 水平控制点偏移量
            oy = b * k; // 垂直控制点偏移量
        ctx.beginPath(); //从椭圆的左端点开始顺时针绘制四条三次贝塞尔曲线
        ctx.moveTo(x - a, y);
        ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
        ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
        ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
        ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
        ctx.closePath();
        ctx.stroke();
    }

    var sun = new Planet({
        coordinate: {
            a: 0,
            b: 0,
            r: 0
        },
        radius: 50,
        color: "rgba(255, 0, 0, 0.8)"
    });

    function frame() {
        ctx.clearRect(0, 0, width, height);
        sun.draw1();
//        Kanvas.requestAnimationFrame.call(window, frame);
    }
    frame();

    canvas.onmousedown = function(e){
        var x = e.clientX,
            y = e.clientY,
            rotateAngle;
        document.onmousemove = function(e){
            rotateAngle = K3D.getRotateAngle();
            rotateAngle.y += (x - e.clientX) * Math.PI / 100;
            rotateAngle.x += (y - e.clientY) * Math.PI / 100;
            K3D.setRotateAngle({rotateXAngle: rotateAngle.x, rotateYAngle: rotateAngle.y});
            x = e.clientX;
            y = e.clientY;
            frame();
        };
        document.onmouseup = function(){
            document.onmousemove = null;
        }
    }

    var wheelType = "mousewheel";
    try{
        document.createEvent("MouseScrollEvents");
        wheelType = "DOMMouseScroll"
    } catch(e){};
    canvas.addEventListener(wheelType, function(event){
        if ("wheelDelta" in event){//统一为±120，其中正数表示为向上滚动，负数表示向下滚动
            var delta = event.wheelDelta;
            //opera 9x系列的滚动方向与IE保持一致，10后修正
            if( window.opera && opera.version() < 10 )
                delta = - delta;
            //由于事件对象的原有属性是只读，我们只能通过添加一个私有属性delta来解决兼容问题
            event.delta = Math.round(delta) / 120; //修正safari的浮点 bug
        } else if( "detail" in event ){
            event.wheelDelta = -event.detail * 40;//为FF添加更大众化的wheelDelta
            event.delta = event.wheelDelta / 120;  //添加私有的delta
        }
        K3D.setCenterPoint(0, 0, K3D.getCenterPoint().z + event.delta * 10);
    }, false);

}());
</script>
</body>
</html>